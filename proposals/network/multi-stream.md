## 整体思路
1. carrier stream层,增加FIFO消息队列处理；
2. stream.write行为，会在底层写入FIFO队列；
3. 在连接建立时，启动connection.write()协程，顺序从FIFO队列中读数据，完成发送；


## 对外接口
_对外提供的接口和之前的stream接口保持一致，上层不需要做调整_

## 可能异常
1. 上层的写操作，会对底层的connection造成竞争使用，考虑如下两种场景：
> a. 上层同时存在stream级写操作和连接级写操作，那么在一个时刻，connection只会被一个写操作使用；
> b. stream之间会存在connection使用竞争；当某一个stream当次发送数据过大的时候，连接会被长久占用;

2. stream异常close
> 和该stream相关的数据包，在底层将会被丢弃,放弃发送； 已经进入重发流程的，则从重发队列里剔除；

3. 在同一个stream上，上层针对同一个包多次发送(msgID相同)
> 如果在底层相同的数据没有处理完毕，上层再次过来相同的包，底层则忽略；如果已经处理完毕，按新包处理；

4. FIFO队列满了
> 通知上层写失败

5. 连接异常关闭
> stream全部关闭；stram相关的资源全部释放；所有基于该连接的数据包全部丢弃;通知上层写失败;

## Q&A
1. writeAndWaitReply相关逻辑考虑如何在异步写的情况下支持。是否为这类消息提高优先级?
> a. 上层发送某消息的时候，会正常入队，等待底层goroutine轮训队列，不做优先级处理；b. 在等待Ack超时的时候，相应的重发消息不会再次入队，而是使用connection.Write()直接发送出去；


2. 明确下使用muti-stream的原因，优势；
>1 增加了一个缓存队列，后续可以针对缓存队列设计各种发送策略，例如之前提到的按优先级发送；2 可以在一定程度上避免一个连接长时间被某个上层服务占有；加了队列后，连接不会直接被上层服务操作了，只在carrier内部被使用；
 存在的问题是：如果上层发送的数据块比较大，可能会导致连接被某个数据块长时间占有；


3. fifo和年前说的优先级队列有没有冲突？
>  不会存在冲突，可以基于一个队列做优先级，也可以开双/三队列做优先级处理，处理方式目前看还是比较灵活的；

4. fifo上限是按长度还是大小？
> 是按照长度做，默认长度是256，上层可以根据自己数据包的最大值，按实际情况配置长度；

5. 能否提供一个canWrite接口让上层知道底层fifo是否可以使用？
> 可以提供一个接口供上层查询FIFO是否已满