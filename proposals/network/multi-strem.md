## 整体思路
1. carrier stream层,增加FIFO消息队列处理；
2. stream.write行为，会在底层写入FIFO队列；
3. 在连接建立时，启动connection.write()协程，顺序从FIFO队列中读数据，完成发送；


## 对外接口
_对外提供的接口和之前的stream接口保持一致，上层不需要做调整_

## 可能异常
1. 上层的写操作，会对底层的connection造成竞争使用，考虑如下两种场景：
> a. 上层同时存在stream级写操作和连接级写操作，那么在一个时刻，connection只会被一个写操作使用；
> b. stream之间会存在connection使用竞争；当某一个stream当次发送数据过大的时候，连接会被长久占用;

2. stream异常close
> 和该stream相关的数据包，在底层将会被丢弃,放弃发送； 已经进入重发流程的，则从重发队列里剔除；

3. 在同一个stream上，上层针对同一个包多次发送(msgID相同)
> 如果在底层相同的数据没有处理完毕，上层再次过来相同的包，底层则忽略；如果已经处理完毕，按新包处理；

4. FIFO队列满了
> 通知上层写失败

5. 连接异常关闭
> stream全部关闭；stram相关的资源全部释放；所有基于该连接的数据包全部丢弃;通知上层写失败;
